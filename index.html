<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image → Pattern Template with Download</title>
  <style>
    :root { --radius: 16px; }
    *{box-sizing:border-box}
    body {
      margin: 0;
      display: grid;
      place-items: center;
      min-height: 100vh;
      background: #1f1f1f;
      color: #fff;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      padding: 24px 12px;
    }
    .app{width:min(980px,100%); display:grid; gap:14px}
    .controls{
      display:grid; gap:10px;
      grid-template-columns: repeat(auto-fit,minmax(220px,1fr));
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding:14px;
    }
    .controls label{display:grid; gap:6px; font-size:14px}
    input[type="file"]{display:block}
    input[type="range"], input[type="text"], input[type="color"]{width:100%}
    button{padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:#2a2a2a; color:#fff; cursor:pointer}
    button[disabled]{opacity:.5; cursor:not-allowed}
    canvas{ width:100%; height:auto; border-radius: var(--radius); border:1px solid rgba(255,255,255,.08); background:#000 }
    .color{display:flex; align-items:center; gap:8px}
    .swatch{width:22px; height:22px; border-radius:6px; border:1px solid rgba(255,255,255,.5)}
    .row{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
    .seg{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .seg label{display:flex; align-items:center; gap:6px}
  </style>
</head>
<body>
  <div class="app">
    <h1>Upload PNG → Center + Surround → Download</h1>

    <div class="controls">
      <label>PNG image
        <input type="file" id="file" accept="image/png" />
      </label>
      <label>Canvas size (px)
        <input type="range" id="canvasSize" min="384" max="1024" step="64" value="512" />
      </label>
      <label>Tile size (px)
        <input type="range" id="tileSize" min="60" max="220" step="2" value="140" />
      </label>
      <label>Rotation (degrees)
        <input type="range" id="rotation" min="0" max="45" step="1" value="15" />
      </label>
      <label>Darken background factor
        <input type="range" id="darken" min="0" max="100" step="5" value="40" />
      </label>
      <label>Ring radius (% of canvas)
        <input type="range" id="radius" min="5" max="50" step="1" value="32" />
      </label>
      <label>Side offset (% of radius)
        <input type="range" id="sideOffset" min="30" max="90" step="1" value="60" />
      </label>
      <label>Background icon opacity (%)
        <input type="range" id="bgAlpha" min="10" max="100" step="5" value="40" />
      </label>

      <label>Background copies (0–8)
        <input type="range" id="bgCount" min="0" max="8" step="1" value="6" />
      </label>

      <div style="grid-column:1/-1; height:1px; background:rgba(255,255,255,.1);"></div>

      <div class="seg" style="grid-column:1/-1">
        <span style="opacity:.8">Color source:</span>
        <label><input type="radio" name="colorMode" value="auto" checked> Auto (dominant)</label>
        <label><input type="radio" name="colorMode" value="picker"> Picker</label>
        <label><input type="radio" name="colorMode" value="manual"> Manual</label>
      </div>
      <label>Picker (roulette)
        <div class="row">
          <input type="color" id="colorPicker" value="#1f1f1f" />
          <div class="swatch" id="swatch"></div>
        </div>
      </label>
      <label>Manual (hex or rgb)
        <input type="text" id="manualColor" placeholder="#aabbcc or rgb(170,187,204)" />
      </label>
      <div class="row" style="grid-column:1/-1">
        <div id="rgb">rgb(31,31,31)</div>
        <button id="download" disabled>Download PNG</button>
      </div>
    </div>

    <canvas id="canvas" width="512" height="512"></canvas>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const fileInput = $('file');
    const downloadBtn = $('download');
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');

    const canvasSize = $('canvasSize');
    const tileSize = $('tileSize');
    const rotationRange = $('rotation');
    const darkenRange = $('darken');
    const radiusRange = $('radius');
    const sideOffsetRange = $('sideOffset');
    const bgAlphaRange = $('bgAlpha');
    const bgCountRange = $('bgCount');

    const swatch = $('swatch');
    const rgbText = $('rgb');
    const manualColor = $('manualColor');
    const colorPicker = $('colorPicker');
    const colorModeRadios = Array.from(document.querySelectorAll('input[name="colorMode"]'));

    let img = null;

    [canvasSize, tileSize, rotationRange, darkenRange, radiusRange, sideOffsetRange, bgAlphaRange, bgCountRange, manualColor, colorPicker, ...colorModeRadios]
      .forEach(el => el.addEventListener('input', () => { resizeCanvas(parseInt(canvasSize.value,10)); if (img) drawPattern(img); }));

    function resizeCanvas(n){ canvas.width = n; canvas.height = n; }

    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file || file.type !== 'image/png') { alert('Please upload a PNG'); return; }
      const fr = new FileReader();
      fr.onload = () => { img = new Image(); img.onload = () => { drawPattern(img); downloadBtn.disabled = false; }; img.src = fr.result; };
      fr.readAsDataURL(file);
    });

    function currentColorMode(){
      const checked = colorModeRadios.find(r => r.checked);
      return checked ? checked.value : 'auto';
    }

    function parseManualColor(str){
      if(!str) return null; str = str.trim();
      const hex = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/; // #rgb or #rrggbb
      if(hex.test(str)){
        let r,g,b; let h = str.slice(1);
        if(h.length===3){ r=parseInt(h[0]+h[0],16); g=parseInt(h[1]+h[1],16); b=parseInt(h[2]+h[2],16);} else { r=parseInt(h.slice(0,2),16); g=parseInt(h.slice(2,4),16); b=parseInt(h.slice(4,6),16);} 
        return {r,g,b};
      }
      const rgb = /^rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
      const m = str.match(rgb);
      if(m){ const r=+m[1], g=+m[2], b=+m[3]; if(r<=255&&g<=255&&b<=255) return {r,g,b}; }
      return null;
    }

    function pickBackgroundColor(image){
      const mode = currentColorMode();
      if(mode==='manual'){
        const parsed = parseManualColor(manualColor.value);
        if(parsed) return parsed;
      }
      if(mode==='picker'){
        const hex = colorPicker.value || '#1f1f1f';
        const parsed = parseManualColor(hex);
        if(parsed) return parsed;
      }
      return extractDominantColor(image); // auto
    }

    function drawPattern(image){
      // 1) background color
      const base = pickBackgroundColor(image);
      const dark = darkenColor(base, parseInt(darkenRange.value,10)/100);
      const bgCss = `rgb(${dark.r},${dark.g},${dark.b})`;
      ctx.fillStyle = bgCss; ctx.fillRect(0,0,canvas.width,canvas.height);
      swatch.style.background = bgCss; rgbText.textContent = bgCss;

      const T = parseInt(tileSize.value,10);
      const cx = canvas.width/2, cy = canvas.height/2;

      // 2) center image
      const maxBig = canvas.width * 0.45;
      const scaleBig = Math.min(maxBig / image.width, maxBig / image.height);
      const wBig = image.width * scaleBig, hBig = image.height * scaleBig;

      // 3) background copies
      const count = parseInt(bgCountRange.value, 10);
      const R = Math.min(canvas.width, canvas.height) * (parseInt(radiusRange.value,10)/100);
      const sideOffset = Math.round(R * (parseInt(sideOffsetRange.value,10)/100));
      const s = T / Math.max(image.width, image.height);
      const wSmall = image.width * s; const hSmall = image.height * s;
      const rot = (parseInt(rotationRange.value,10) * Math.PI) / 180;

      // Positions: if count == 6 → diamond/emerald (two per side). Else → evenly spaced circle (starting from top).
      let positions = [];
      if(count === 6){
        positions = [
          {x:cx,   y:cy-R,               role:'top'},
          {x:cx+R, y:cy-sideOffset,      role:'rightTop'},
          {x:cx+R, y:cy+sideOffset,      role:'rightBottom'},
          {x:cx,   y:cy+R,               role:'bottom'},
          {x:cx-R, y:cy+sideOffset,      role:'leftBottom'},
          {x:cx-R, y:cy-sideOffset,      role:'leftTop'},
        ];
      } else {
        for(let i=0;i<count;i++){
          const ang = (-90 + i * (360 / Math.max(1,count))) * Math.PI / 180; // start at top
          positions.push({ x: cx + R * Math.cos(ang), y: cy + R * Math.sin(ang), idx:i });
        }
      }

      positions.forEach((p, i) => {
        ctx.save();
        ctx.globalAlpha = Math.max(0.01, parseInt(bgAlphaRange.value,10)/100);
        ctx.translate(p.x, p.y);
        // Rotation rule: for 6-diamond use your spec; for circle alternate starting with right at top
        let angle = 0;
        if(count === 6){
          const role = p.role;
          if(role==='top' || role==='rightBottom' || role==='leftBottom') angle = +rot; else angle = -rot;
        } else {
          angle = (i % 2 === 0) ? +rot : -rot; // alternate
        }
        ctx.rotate(angle);
        ctx.drawImage(image, -wSmall/2, -hSmall/2, wSmall, hSmall);
        ctx.restore();
      });

      // 4) draw center last
      ctx.drawImage(image, cx-wBig/2, cy-hBig/2, wBig, hBig);
    }

    function extractDominantColor(image){
      const c = document.createElement('canvas'); c.width = 128; c.height = 128;
      const cx = c.getContext('2d', { willReadFrequently:true });
      cx.drawImage(image,0,0,c.width,c.height);
      const data = cx.getImageData(0,0,c.width,c.height).data;
      const bins = new Uint32Array(4096); const sumR = new Uint32Array(4096); const sumG = new Uint32Array(4096); const sumB = new Uint32Array(4096);
      for (let i=0;i<data.length;i+=4){ const a=data[i+3]; if(a<120) continue; const r=data[i],g=data[i+1],b=data[i+2]; const idx=((r>>4)<<8)|((g>>4)<<4)|(b>>4); bins[idx]++; sumR[idx]+=r; sumG[idx]+=g; sumB[idx]+=b; }
      let best=0, idx=0; for(let k=0;k<4096;k++){ if(bins[k]>best){best=bins[k]; idx=k;} }
      if(!best) return {r:32,g:32,b:32};
      return { r: Math.round(sumR[idx]/best), g: Math.round(sumG[idx]/best), b: Math.round(sumB[idx]/best) };
    }

    function darkenColor({r,g,b}, factor){
      const {h,s,l} = rgbToHsl(r,g,b);
      const newL = Math.max(0, l * (1 - factor));
      const {r:rr,g:gg,b:bb} = hslToRgb(h,s,newL);
      return {r:rr,g:gg,b:bb};
    }

    function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){h=s=0;} else { const d=max-min; s=l>0.5? d/(2-max-min): d/(max+min); switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h/=6;} return {h,s,l}; }
    function hslToRgb(h,s,l){ let r,g,b; if(s===0){r=g=b=l;} else { const hue2rgb=(p,q,t)=>{ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; }; const q=l<0.5? l*(1+s): l+s-l*s; const p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);} return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)}; }

    downloadBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'template-' + Math.random().toString(36).slice(2,10) + '.png';
      link.href = canvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    resizeCanvas(parseInt(canvasSize.value,10));
  </script>
</body>
</html>
